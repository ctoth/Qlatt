<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>QLATT Test Harness</title>
    <style>
      :root {
        color-scheme: light;
        --ink: #1e2023;
        --muted: #5f6368;
        --panel: #f5f1ea;
        --accent: #c16f3e;
        --accent-dark: #8f4e2d;
        --border: #d7cbbd;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        background: radial-gradient(circle at top right, #f8efe2, #efe6da 50%, #e6dccf 100%);
        color: var(--ink);
      }
      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 32px 20px 60px;
      }
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 28px;
      }
      h1 {
        margin: 0;
        font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
        font-size: 2.2rem;
        letter-spacing: 0.02em;
      }
      .sub {
        color: var(--muted);
        margin-top: 6px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 20px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.06);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
      }
      .control {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label {
        font-weight: 600;
      }
      input[type="range"] {
        width: 100%;
      }
      .value {
        font-family: "Consolas", "Courier New", monospace;
        font-size: 0.9rem;
        color: var(--muted);
      }
      button {
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-weight: 700;
        cursor: pointer;
        background: var(--accent);
        color: #fff;
        transition: transform 0.15s ease, background 0.15s ease;
      }
      button:hover {
        background: var(--accent-dark);
        transform: translateY(-1px);
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .status {
        font-size: 0.95rem;
        color: var(--muted);
      }
      @media (max-width: 600px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <div>
          <h1>QLATT Synth Harness</h1>
          <div class="sub">LF source → diff → cascade resonators</div>
        </div>
        <div class="row">
          <button id="startBtn">Start Audio</button>
          <button id="stopBtn">Stop Audio</button>
        </div>
      </header>

      <section class="panel">
        <div class="row" style="margin-bottom: 16px;">
          <label for="phrase">Phrase</label>
          <input id="phrase" type="text" value="hello world" style="flex: 1; min-width: 220px;" />
          <label for="baseF0">Base F0</label>
          <input id="baseF0" type="number" value="110" min="60" max="220" step="1" style="width: 80px;" />
          <button id="speakBtn">Speak</button>
        </div>
        <div class="grid" id="controls"></div>
      </section>
      <section class="panel" style="margin-top: 18px;">
        <div class="row" style="margin-bottom: 10px;">
          <strong>Diagnostics</strong>
          <button id="copyDiagBtn">Copy diagnostics</button>
          <button id="clearDiagBtn">Clear</button>
        </div>
        <textarea id="diagnostics" rows="8" style="width: 100%; font-family: Consolas, 'Courier New', monospace;" readonly></textarea>
      </section>
      <p class="status" id="status">Status: idle</p>
    </main>

    <script type="module">
      import { KlattSynth } from "../src/klatt-synth.js";
      import { textToKlattTrack } from "../src/tts-frontend.js";

      const ctx = new AudioContext();
      const synth = new KlattSynth(ctx);
      const status = document.getElementById("status");
      const controls = document.getElementById("controls");
      const diagnosticsEl = document.getElementById("diagnostics");
      const telemetry = new Map();
      const telemetryMax = new Map();
      const meters = new Map();
      const meterValues = new Map();
      const meterMax = new Map();
      let lastRun = null;
      let telemetryTimer = null;
      let meterTimer = null;
      let lastDiagnostics = "";

      const controlSpec = [
        { id: "f0", label: "F0 (Hz)", min: 50, max: 300, step: 1 },
        { id: "rd", label: "Rd", min: 0.3, max: 2.7, step: 0.01 },
        { id: "voiceGain", label: "Voice Gain", min: 0, max: 1, step: 0.01 },
        { id: "noiseGain", label: "Noise Gain", min: 0, max: 0.5, step: 0.01 },
        { id: "noiseCutoff", label: "Noise Cutoff", min: 200, max: 6000, step: 10 },
        { id: "fricationCutoff", label: "Frication Cutoff", min: 500, max: 9000, step: 10 },
        { id: "masterGain", label: "Output Boost", min: 0, max: 5, step: 0.05 },
        { id: "parallelMix", label: "Parallel Mix", min: 0, max: 1, step: 0.01 },
        { id: "parallelVoiceGain", label: "Parallel Voice", min: 0, max: 1, step: 0.01 },
        { id: "parallelFricationGain", label: "Parallel Frication", min: 0, max: 1, step: 0.01 },
        { id: "AB", label: "Bypass (AB dB)", min: -70, max: 70, step: 1 },
        { id: "AN", label: "Nasal (AN dB)", min: -70, max: 70, step: 1 },
        { id: "A1", label: "A1 (dB)", min: -70, max: 70, step: 1 },
        { id: "A2", label: "A2 (dB)", min: -70, max: 70, step: 1 },
        { id: "A3", label: "A3 (dB)", min: -70, max: 70, step: 1 },
        { id: "A4", label: "A4 (dB)", min: -70, max: 70, step: 1 },
        { id: "A5", label: "A5 (dB)", min: -70, max: 70, step: 1 },
        { id: "A6", label: "A6 (dB)", min: -70, max: 70, step: 1 },
        { id: "F1", label: "F1 (Hz)", min: 200, max: 1000, step: 1 },
        { id: "F2", label: "F2 (Hz)", min: 500, max: 2500, step: 1 },
        { id: "F3", label: "F3 (Hz)", min: 1500, max: 3500, step: 1 },
        { id: "B1", label: "B1 (Hz)", min: 30, max: 200, step: 1 },
        { id: "B2", label: "B2 (Hz)", min: 40, max: 300, step: 1 },
        { id: "B3", label: "B3 (Hz)", min: 60, max: 400, step: 1 },
        { id: "FNZ", label: "Nasal Zero (FNZ)", min: 100, max: 1000, step: 1 },
        { id: "BNZ", label: "Nasal Zero BW", min: 50, max: 500, step: 1 },
        { id: "FNP", label: "Nasal Pole (FNP)", min: 100, max: 1000, step: 1 },
        { id: "BNP", label: "Nasal Pole BW", min: 50, max: 500, step: 1 },
      ];

      function renderControls() {
        for (const spec of controlSpec) {
          const wrapper = document.createElement("div");
          wrapper.className = "control";
          const label = document.createElement("label");
          label.textContent = spec.label;
          const input = document.createElement("input");
          input.type = "range";
          input.min = spec.min;
          input.max = spec.max;
          input.step = spec.step;
          input.id = spec.id;
          const value = document.createElement("div");
          value.className = "value";
          value.id = `${spec.id}-value`;
          wrapper.append(label, input, value);
          controls.append(wrapper);
        }
      }

      function bindControls() {
        for (const spec of controlSpec) {
          const input = document.getElementById(spec.id);
          const value = document.getElementById(`${spec.id}-value`);
          const initial = synth.params[spec.id];
          input.value = initial;
          value.textContent = Number(initial).toFixed(2);
          input.addEventListener("input", () => {
            const v = Number(input.value);
            value.textContent = v.toFixed(2);
            synth.setParam(spec.id, v);
          });
        }
      }

      async function start() {
        await synth.initialize();
        await ctx.resume();
        status.textContent = "Status: running";
      }

      async function stop() {
        await ctx.suspend();
        status.textContent = "Status: suspended";
      }

      async function speak() {
        await synth.initialize();
        await ctx.resume();
        const phrase = document.getElementById("phrase").value.trim();
        const baseF0 = Number(document.getElementById("baseF0").value) || 110;
        if (!phrase) return;
        const track = textToKlattTrack(phrase, baseF0);
        synth.scheduleTrack(track, ctx.currentTime + 0.05);
        status.textContent = `Status: speaking "${phrase}"`;
        lastRun = { phrase, baseF0, track };
        telemetry.clear();
        telemetryMax.clear();
        meterMax.clear();
        updateDiagnostics();
        console.log("[QLATT] Track summary", summarizeTrack(track));
        const parallelSummary = summarizeParallel(track);
        console.log("[QLATT] Parallel summary", parallelSummary);
        if (parallelSummary.parallelEvents > 0 && parallelSummary.swOn === 0) {
          console.warn(
            "[QLATT] Parallel params present, but SW=0 (cascade-only path)."
          );
        }
        console.log("[QLATT] First events", track.slice(0, 6));
      }

      renderControls();
      (async () => {
        synth.setTelemetryHandler(handleTelemetry);
        await synth.initialize();
        attachMeters();
        bindControls();
      })();

      document.getElementById("startBtn").addEventListener("click", start);
      document.getElementById("stopBtn").addEventListener("click", stop);
      document.getElementById("speakBtn").addEventListener("click", speak);
      document.getElementById("copyDiagBtn").addEventListener("click", async () => {
        if (!lastRun) return;
        updateDiagnostics();
        await navigator.clipboard.writeText(lastDiagnostics);
      });
      document.getElementById("clearDiagBtn").addEventListener("click", () => {
        diagnosticsEl.value = "";
        lastDiagnostics = "";
        lastRun = null;
        telemetry.clear();
        telemetryMax.clear();
        meterValues.clear();
        meterMax.clear();
      });

      function summarizeTrack(track) {
        const totalTime = track.length ? track[track.length - 1].time : 0;
        const voiced = track.filter((e) => (e.params?.AV ?? 0) > 0 || (e.params?.AVS ?? 0) > 0);
        const f0Values = track.map((e) => e.params?.F0 ?? 0).filter((v) => v > 0);
        const f0Min = f0Values.length ? Math.min(...f0Values) : 0;
        const f0Max = f0Values.length ? Math.max(...f0Values) : 0;
        return {
          events: track.length,
          totalTime,
          voicedEvents: voiced.length,
          f0Min,
          f0Max,
        };
      }

      function summarizeParallel(track) {
        let swOn = 0;
        let swOff = 0;
        let parallelEvents = 0;
        let swOnSeconds = 0;
        let swTotalSeconds = 0;
        for (const event of track) {
          const params = event.params;
          if (!params) continue;
          if (params.SW === 1) swOn += 1;
          else if (Number.isFinite(params.SW)) swOff += 1;
          const hasParallel =
            (params.AN ?? 0) > 0 ||
            (params.AB ?? 0) > 0 ||
            [params.A1, params.A2, params.A3, params.A4, params.A5, params.A6].some(
              (v) => (v ?? 0) > 0
            ) ||
            (params.AVS ?? 0) > 0 ||
            (params.AF ?? 0) > 0;
          if (hasParallel) parallelEvents += 1;
        }
        for (let i = 0; i < track.length - 1; i += 1) {
          const params = track[i]?.params;
          const duration = track[i + 1].time - track[i].time;
          if (!Number.isFinite(duration) || duration <= 0) continue;
          if (params && Number.isFinite(params.SW)) {
            swTotalSeconds += duration;
            if (params.SW === 1) swOnSeconds += duration;
          }
        }
        const swOnShare =
          swTotalSeconds > 0 ? (swOnSeconds / swTotalSeconds) * 100 : 0;
        return { swOn, swOff, parallelEvents, swOnSeconds, swOnShare };
      }

      function formatLevel(value) {
        if (!Number.isFinite(value)) return "n/a";
        if (value === 0) return "0";
        const abs = Math.abs(value);
        if (abs < 1e-6) return value.toExponential(2);
        return value.toFixed(6);
      }

      function formatTelemetry(map) {
        if (!map || map.size === 0) return ["(no telemetry yet)"];
        const entries = Array.from(map.entries()).sort(([a], [b]) =>
          a.localeCompare(b)
        );
        return entries.map(
          ([node, data]) => {
            let suffix = "";
            if (Number.isFinite(data.f0) || Number.isFinite(data.rd)) {
              const f0 = Number.isFinite(data.f0) ? data.f0.toFixed(2) : "n/a";
              const rd = Number.isFinite(data.rd) ? data.rd.toFixed(2) : "n/a";
              suffix = ` f0=${f0} rd=${rd}`;
            }
            const max = telemetryMax.get(node);
            let maxSuffix = "";
            if (max) {
              const maxRms = formatLevel(max.rms);
              const maxPeak = formatLevel(max.peak);
              maxSuffix = ` | max rms=${maxRms} peak=${maxPeak}`;
              if (Number.isFinite(max.f0) || Number.isFinite(max.rd)) {
                const maxF0 = Number.isFinite(max.f0) ? max.f0.toFixed(2) : "n/a";
                const maxRd = Number.isFinite(max.rd) ? max.rd.toFixed(2) : "n/a";
                maxSuffix += ` f0=${maxF0} rd=${maxRd}`;
              }
            }
            return `${node}: rms=${formatLevel(data.rms)} peak=${formatLevel(data.peak)}${suffix}${maxSuffix}`;
          }
        );
      }

      function formatMeters(map) {
        if (!map || map.size === 0) return ["(no meters yet)"];
        const entries = Array.from(map.entries()).sort(([a], [b]) =>
          a.localeCompare(b)
        );
        return entries.map(
          ([node, data]) => {
            const max = meterMax.get(node);
            let suffix = "";
            if (max) {
              suffix = ` | max rms=${formatLevel(max.rms)} peak=${formatLevel(
                max.peak
              )}`;
            }
            return `${node}: rms=${formatLevel(data.rms)} peak=${formatLevel(
              data.peak
            )}${suffix}`;
          }
        );
      }

      function updateDiagnostics() {
        if (!lastRun) return;
        lastDiagnostics = buildDiagnostics({
          phrase: lastRun.phrase,
          baseF0: lastRun.baseF0,
          track: lastRun.track,
          telemetry,
          meters: meterValues,
        });
        diagnosticsEl.value = lastDiagnostics;
      }

      function handleTelemetry(data) {
        if (!data?.node) return;
        telemetry.set(data.node, {
          rms: data.rms,
          peak: data.peak,
          f0: data.f0,
          rd: data.rd,
        });
        const prev = telemetryMax.get(data.node);
        const next = {
          rms: Math.max(prev?.rms ?? 0, data.rms ?? 0),
          peak: Math.max(prev?.peak ?? 0, data.peak ?? 0),
          f0: Math.max(prev?.f0 ?? 0, data.f0 ?? 0),
          rd: Math.max(prev?.rd ?? 0, data.rd ?? 0),
        };
        telemetryMax.set(data.node, next);
        if (!lastRun) return;
        if (telemetryTimer) return;
        telemetryTimer = setTimeout(() => {
          telemetryTimer = null;
          updateDiagnostics();
        }, 250);
      }

      function buildDiagnostics({ phrase, baseF0, track, telemetry, meters }) {
        const summary = summarizeTrack(track);
        const parallelSummary = summarizeParallel(track);
        const lines = [];
        lines.push(`Phrase: ${phrase}`);
        lines.push(`Base F0: ${baseF0}`);
        lines.push(`Events: ${summary.events}`);
        lines.push(`Total time: ${summary.totalTime.toFixed(3)}s`);
        lines.push(`Voiced events: ${summary.voicedEvents}`);
        lines.push(`F0 range: ${summary.f0Min.toFixed(1)} - ${summary.f0Max.toFixed(1)} Hz`);
        lines.push(
          `SW=1 events: ${parallelSummary.swOn} | parallel events: ${parallelSummary.parallelEvents}`
        );
        lines.push(
          `SW=1 time: ${parallelSummary.swOnSeconds.toFixed(3)}s (${parallelSummary.swOnShare.toFixed(1)}%)`
        );
        lines.push("");
        lines.push("First events:");
        track.slice(0, 8).forEach((e, index) => {
          lines.push(
            `${index}. t=${e.time.toFixed(3)} ${e.phoneme ?? ""} F0=${(e.params?.F0 ?? 0).toFixed(1)} AV=${(e.params?.AV ?? 0).toFixed(1)} AVS=${(e.params?.AVS ?? 0).toFixed(1)} AF=${(e.params?.AF ?? 0).toFixed(1)}`
          );
        });
        lines.push("");
        lines.push("Last events:");
        track.slice(-6).forEach((e, index) => {
          lines.push(
            `${track.length - 6 + index}. t=${e.time.toFixed(3)} ${e.phoneme ?? ""} F0=${(e.params?.F0 ?? 0).toFixed(1)} AV=${(e.params?.AV ?? 0).toFixed(1)} AVS=${(e.params?.AVS ?? 0).toFixed(1)} AF=${(e.params?.AF ?? 0).toFixed(1)}`
          );
        });
        lines.push("");
        lines.push("Telemetry (latest block):");
        lines.push(...formatTelemetry(telemetry));
        lines.push("");
        lines.push("Meters (RMS/peak):");
        lines.push(...formatMeters(meters || meterValues));
        return lines.join("\n");
      }

      function attachMeters() {
        const nodes = synth.nodes;
        if (!nodes?.outputSum || meters.size > 0) return;
        const targets = [
          { name: "cascade-out", node: nodes.cascadeOutGain },
          { name: "parallel-out", node: nodes.parallelOutGain },
          { name: "output-sum", node: nodes.outputSum },
        ];
        for (const target of targets) {
          if (!target.node) continue;
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          target.node.connect(analyser);
          meters.set(target.name, analyser);
        }
        startMeterLoop();
      }

      function startMeterLoop() {
        if (meterTimer) return;
        meterTimer = setInterval(() => {
          for (const [name, analyser] of meters.entries()) {
            const data = readMeter(analyser);
            meterValues.set(name, data);
            const prev = meterMax.get(name);
            if (!prev) {
              meterMax.set(name, { ...data });
            } else {
              meterMax.set(name, {
                rms: Math.max(prev.rms, data.rms),
                peak: Math.max(prev.peak, data.peak),
              });
            }
          }
          updateDiagnostics();
        }, 200);
      }

      function readMeter(analyser) {
        const buffer = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(buffer);
        let sum = 0;
        let peak = 0;
        for (let i = 0; i < buffer.length; i += 1) {
          const v = buffer[i];
          sum += v * v;
          const av = Math.abs(v);
          if (av > peak) peak = av;
        }
        const rms = Math.sqrt(sum / buffer.length);
        return { rms, peak };
      }
    </script>
  </body>
</html>
