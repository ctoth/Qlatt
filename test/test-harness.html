<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>QLATT Test Harness</title>
    <style>
      :root {
        color-scheme: light;
        --ink: #1e2023;
        --muted: #5f6368;
        --panel: #f5f1ea;
        --accent: #c16f3e;
        --accent-dark: #8f4e2d;
        --border: #d7cbbd;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        background: radial-gradient(circle at top right, #f8efe2, #efe6da 50%, #e6dccf 100%);
        color: var(--ink);
      }
      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 32px 20px 60px;
      }
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 28px;
      }
      h1 {
        margin: 0;
        font-family: "Palatino Linotype", "Book Antiqua", Palatino, serif;
        font-size: 2.2rem;
        letter-spacing: 0.02em;
      }
      .sub {
        color: var(--muted);
        margin-top: 6px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: 20px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.06);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 16px;
      }
      .control {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      label {
        font-weight: 600;
      }
      input[type="range"] {
        width: 100%;
      }
      .value {
        font-family: "Consolas", "Courier New", monospace;
        font-size: 0.9rem;
        color: var(--muted);
      }
      button {
        border: none;
        border-radius: 999px;
        padding: 10px 18px;
        font-weight: 700;
        cursor: pointer;
        background: var(--accent);
        color: #fff;
        transition: transform 0.15s ease, background 0.15s ease;
      }
      button:hover {
        background: var(--accent-dark);
        transform: translateY(-1px);
      }
      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }
      .spectrogram canvas {
        width: 100%;
        height: 200px;
        background: #111;
        border-radius: 14px;
        display: block;
      }
      .status {
        font-size: 0.95rem;
        color: var(--muted);
      }
      @media (max-width: 600px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <div>
          <h1>QLATT Synth Harness</h1>
          <div class="sub">LF source → diff → cascade resonators</div>
        </div>
        <div class="row">
          <button id="startBtn">Start Audio</button>
          <button id="stopBtn">Stop Audio</button>
        </div>
      </header>

      <section class="panel">
        <div class="row" style="margin-bottom: 16px;">
          <label for="phrase">Phrase</label>
          <input id="phrase" type="text" value="hello world" style="flex: 1; min-width: 220px;" />
          <label for="baseF0">Base F0</label>
          <input id="baseF0" type="number" value="110" min="60" max="220" step="1" style="width: 80px;" />
          <button id="speakBtn">Speak</button>
        </div>
        <div class="grid" id="controls"></div>
      </section>
      <section class="panel" style="margin-top: 18px;">
        <div class="row" style="margin-bottom: 10px;">
          <strong>Diagnostics</strong>
          <button id="copyDiagBtn">Copy diagnostics</button>
          <button id="clearDiagBtn">Clear</button>
        </div>
        <textarea id="diagnostics" rows="8" style="width: 100%; font-family: Consolas, 'Courier New', monospace;" readonly></textarea>
      </section>
      <section class="panel spectrogram" style="margin-top: 18px;">
        <div class="row" style="margin-bottom: 10px;">
          <strong>Spectrogram</strong>
          <button id="clearSpecBtn">Clear</button>
        </div>
        <canvas id="spectrogram" width="900" height="240"></canvas>
      </section>
      <p class="status" id="status">Status: idle</p>
    </main>

    <script type="module">
      import { KlattSynth } from "../src/klatt-synth.js";
      import { textToKlattTrack } from "../src/tts-frontend.js";

      const ctx = new AudioContext();
      const synth = new KlattSynth(ctx);
      const status = document.getElementById("status");
      const controls = document.getElementById("controls");
      const diagnosticsEl = document.getElementById("diagnostics");
      const telemetry = new Map();
      const telemetryMax = new Map();
      const meters = new Map();
      const meterValues = new Map();
      const meterMax = new Map();
      const spikeEvents = [];
      const lastSpikeAt = new Map();
      const specCanvas = document.getElementById("spectrogram");
      const specCtx = specCanvas?.getContext("2d");
      const specState = {
        analyser: null,
        running: false,
        rafId: 0,
      };
      let lastRun = null;
      let runStartTime = 0;
      let telemetryTimer = null;
      let meterTimer = null;
      let lastDiagnostics = "";
      const spikeThreshold = 1.0;
      const spikeCooldown = 0.2;

      const controlSpec = [
        { id: "f0", label: "F0 (Hz)", min: 50, max: 300, step: 1 },
        { id: "rd", label: "Rd", min: 0.3, max: 2.7, step: 0.01 },
        {
          id: "lfMode",
          label: "LF Mode (0=Legacy, 1=LF_LM, 2=LF_CALM)",
          min: 0,
          max: 2,
          step: 1,
          format: "fixed0",
        },
        { id: "voiceGain", label: "Voice Gain", min: 0, max: 1, step: 0.01 },   
        { id: "noiseGain", label: "Noise Gain", min: 0, max: 0.5, step: 0.01 }, 
        { id: "noiseCutoff", label: "Noise Cutoff", min: 200, max: 6000, step: 10 },
        { id: "fricationCutoff", label: "Frication Cutoff", min: 500, max: 9000, step: 10 },
        { id: "masterGain", label: "Output Boost", min: 0, max: 5, step: 0.05 },
        { id: "parallelMix", label: "Parallel Mix", min: 0, max: 1, step: 0.01 },
        { id: "parallelGainScale", label: "Parallel Gain Scale", min: 0, max: 1, step: 0.01, format: "fixed2" },
        { id: "parallelVoiceGain", label: "Parallel Voice", min: 0, max: 1, step: 0.01 },
        { id: "parallelFricationGain", label: "Parallel Frication", min: 0, max: 1, step: 0.01 },
        { id: "AB", label: "Bypass (AB dB)", min: -70, max: 70, step: 1 },
        { id: "AN", label: "Nasal (AN dB)", min: -70, max: 70, step: 1 },
        { id: "A1", label: "A1 (dB)", min: -70, max: 70, step: 1 },
        { id: "A2", label: "A2 (dB)", min: -70, max: 70, step: 1 },
        { id: "A3", label: "A3 (dB)", min: -70, max: 70, step: 1 },
        { id: "A4", label: "A4 (dB)", min: -70, max: 70, step: 1 },
        { id: "A5", label: "A5 (dB)", min: -70, max: 70, step: 1 },
        { id: "A6", label: "A6 (dB)", min: -70, max: 70, step: 1 },
        { id: "F1", label: "F1 (Hz)", min: 200, max: 1000, step: 1 },
        { id: "F2", label: "F2 (Hz)", min: 500, max: 2500, step: 1 },
        { id: "F3", label: "F3 (Hz)", min: 1500, max: 3500, step: 1 },
        { id: "B1", label: "B1 (Hz)", min: 30, max: 200, step: 1 },
        { id: "B2", label: "B2 (Hz)", min: 40, max: 300, step: 1 },
        { id: "B3", label: "B3 (Hz)", min: 60, max: 400, step: 1 },
        { id: "FNZ", label: "Nasal Zero (FNZ)", min: 100, max: 1000, step: 1 },
        { id: "BNZ", label: "Nasal Zero BW", min: 50, max: 500, step: 1 },
        { id: "FNP", label: "Nasal Pole (FNP)", min: 100, max: 1000, step: 1 },
        { id: "BNP", label: "Nasal Pole BW", min: 50, max: 500, step: 1 },
      ];

      function renderControls() {
        for (const spec of controlSpec) {
          const wrapper = document.createElement("div");
          wrapper.className = "control";
          const label = document.createElement("label");
          label.textContent = spec.label;
          const input = document.createElement("input");
          input.type = "range";
          input.min = spec.min;
          input.max = spec.max;
          input.step = spec.step;
          input.id = spec.id;
          const value = document.createElement("div");
          value.className = "value";
          value.id = `${spec.id}-value`;
          wrapper.append(label, input, value);
          controls.append(wrapper);
        }
      }

      function formatValue(spec, value) {
        if (spec.format === "fixed4") return Number(value).toFixed(4);
        if (spec.format === "fixed2") return Number(value).toFixed(2);
        if (spec.format === "fixed0") return Number(value).toFixed(0);
        return Number(value).toFixed(2);
      }

      function bindControls() {
        for (const spec of controlSpec) {
          const input = document.getElementById(spec.id);
          const value = document.getElementById(`${spec.id}-value`);
          const initial = synth.params[spec.id];
          input.value = initial;
          value.textContent = formatValue(spec, initial);
          input.addEventListener("input", () => {
            const v = Number(input.value);
            value.textContent = formatValue(spec, v);
            synth.setParam(spec.id, v);
          });
        }
      }

      async function start() {
        await synth.initialize();
        await ctx.resume();
        status.textContent = "Status: running";
      }

      async function stop() {
        await ctx.suspend();
        status.textContent = "Status: suspended";
      }

      async function speak() {
        await synth.initialize();
        await ctx.resume();
        const phrase = document.getElementById("phrase").value.trim();
        const baseF0 = Number(document.getElementById("baseF0").value) || 110;
        if (!phrase) return;
        const track = textToKlattTrack(phrase, baseF0);
        const startTime = ctx.currentTime + 0.05;
        synth.scheduleTrack(track, startTime);
        status.textContent = `Status: speaking "${phrase}"`;
        lastRun = { phrase, baseF0, track };
        runStartTime = startTime;
        spikeEvents.length = 0;
        plstepEvents.length = 0;
        lastSpikeAt.clear();
        telemetry.clear();
        telemetryMax.clear();
        meterMax.clear();
        updateDiagnostics();
        console.log("[QLATT] Track summary", summarizeTrack(track));
        const parallelSummary = summarizeParallel(track);
        console.log("[QLATT] Parallel summary", parallelSummary);
        if (parallelSummary.parallelEvents > 0 && parallelSummary.swOn === 0) {
          console.warn(
            "[QLATT] Parallel params present, but SW=0 (cascade-only path)."
          );
        }
        console.log("[QLATT] First events", track.slice(0, 6));
        startSpectrogram(track);
      }

      renderControls();
      (async () => {
        synth.setTelemetryHandler(handleTelemetry);
        await synth.initialize();
        attachMeters();
        attachSpectrogram();
        bindControls();
      })();

      document.getElementById("startBtn").addEventListener("click", start);
      document.getElementById("stopBtn").addEventListener("click", stop);
      document.getElementById("speakBtn").addEventListener("click", speak);
      document.getElementById("copyDiagBtn").addEventListener("click", async () => {
        if (!lastRun) return;
        updateDiagnostics();
        await navigator.clipboard.writeText(lastDiagnostics);
      });
      document.getElementById("clearSpecBtn").addEventListener("click", () => {
        clearSpectrogram();
      });
      document.getElementById("clearDiagBtn").addEventListener("click", () => {
        diagnosticsEl.value = "";
        lastDiagnostics = "";
        lastRun = null;
        runStartTime = 0;
        spikeEvents.length = 0;
        plstepEvents.length = 0;
        lastSpikeAt.clear();
        telemetry.clear();
        telemetryMax.clear();
        meterValues.clear();
        meterMax.clear();
      });

      function summarizeTrack(track) {
        const totalTime = track.length ? track[track.length - 1].time : 0;
        const voiced = track.filter((e) => (e.params?.AV ?? 0) > 0 || (e.params?.AVS ?? 0) > 0);
        const f0Values = track.map((e) => e.params?.F0 ?? 0).filter((v) => v > 0);
        const f0Min = f0Values.length ? Math.min(...f0Values) : 0;
        const f0Max = f0Values.length ? Math.max(...f0Values) : 0;
        return {
          events: track.length,
          totalTime,
          voicedEvents: voiced.length,
          f0Min,
          f0Max,
        };
      }

      function attachSpectrogram() {
        if (!specCtx || !specCanvas) return;
        specState.analyser = ctx.createAnalyser();
        specState.analyser.fftSize = 1024;
        specState.analyser.smoothingTimeConstant = 0;
        synth.nodes.masterGain.connect(specState.analyser);
        clearSpectrogram();
      }

      function clearSpectrogram() {
        if (!specCtx || !specCanvas) return;
        specCtx.fillStyle = "#111";
        specCtx.fillRect(0, 0, specCanvas.width, specCanvas.height);
      }

      function startSpectrogram(track) {
        if (!specState.analyser || !specCtx || !specCanvas) return;
        const duration =
          track && track.length ? track[track.length - 1].time : 0.5;
        specState.running = true;
        const bins = new Uint8Array(specState.analyser.frequencyBinCount);
        const draw = () => {
          if (!specState.running) return;
          specState.analyser.getByteFrequencyData(bins);
          const width = specCanvas.width;
          const height = specCanvas.height;
          specCtx.drawImage(specCanvas, -1, 0);
          for (let y = 0; y < height; y += 1) {
            const idx = Math.floor((y / height) * bins.length);
            const v = bins[idx];
            const c = v.toString(16).padStart(2, "0");
            specCtx.fillStyle = `#${c}${c}${c}`;
            specCtx.fillRect(width - 1, height - 1 - y, 1, 1);
          }
          specState.rafId = requestAnimationFrame(draw);
        };
        if (specState.rafId) cancelAnimationFrame(specState.rafId);
        specState.rafId = requestAnimationFrame(draw);
        setTimeout(() => {
          specState.running = false;
        }, Math.max(0, duration * 1000 + 200));
      }

      function summarizeParallel(track) {
        let swOn = 0;
        let swOff = 0;
        let parallelEvents = 0;
        let swOnSeconds = 0;
        let swTotalSeconds = 0;
        for (const event of track) {
          const params = event.params;
          if (!params) continue;
          if (params.SW === 1) swOn += 1;
          else if (Number.isFinite(params.SW)) swOff += 1;
          const hasParallel =
            (params.AN ?? 0) > 0 ||
            (params.AB ?? 0) > 0 ||
            [params.A1, params.A2, params.A3, params.A4, params.A5, params.A6].some(
              (v) => (v ?? 0) > 0
            ) ||
            (params.AVS ?? 0) > 0 ||
            (params.AF ?? 0) > 0;
          if (hasParallel) parallelEvents += 1;
        }
        for (let i = 0; i < track.length - 1; i += 1) {
          const params = track[i]?.params;
          const duration = track[i + 1].time - track[i].time;
          if (!Number.isFinite(duration) || duration <= 0) continue;
          if (params && Number.isFinite(params.SW)) {
            swTotalSeconds += duration;
            if (params.SW === 1) swOnSeconds += duration;
          }
        }
        const swOnShare =
          swTotalSeconds > 0 ? (swOnSeconds / swTotalSeconds) * 100 : 0;
        return { swOn, swOff, parallelEvents, swOnSeconds, swOnShare };
      }

      function dbToLinear(db) {
        if (!Number.isFinite(db) || db <= -72) return 0;
        const clamped = Math.min(96, db);
        return 2 ** (clamped / 6);
      }

      function updateRange(range, value) {
        if (!Number.isFinite(value)) return range;
        if (!range) return { min: value, max: value };
        range.min = Math.min(range.min, value);
        range.max = Math.max(range.max, value);
        return range;
      }

      function analyzeTrackGains(track, synthParams) {
        if (!track || track.length === 0) return null;
        const ranges = {
          voiceGain: null,
          aspGain: null,
          fricGain: null,
          parallelVoiceGain: null,
          parallelBypassGain: null,
          parallelFormantGain: null,
          parallelNasalGain: null,
          masterGain: null,
          mix: null,
        };
        const ndbScale = {
          A1: -58,
          A2: -65,
          A3: -73,
          A4: -78,
          A5: -79,
          A6: -80,
          AN: -58,
          AB: -84,
          AV: -72,
          // AH changed from -102 to -72 to match AV/AF (see klatt-synth.js)
          AH: -72,
          AF: -72,
          AVS: -44,
        };
        const outputScale = dbToLinear(ndbScale.AF + 44);
        const ndbCor = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
        const proximity = (delta) => {
          if (!Number.isFinite(delta) || delta < 50 || delta >= 550) return 0;
          const index = Math.floor(delta / 50) - 1;
          return ndbCor[Math.max(0, Math.min(index, ndbCor.length - 1))] ?? 0;
        };
        const parallelScale = Number.isFinite(synthParams.parallelGainScale)
          ? synthParams.parallelGainScale
          : 1.0;
        const baseBoost = Number.isFinite(synthParams.masterGain)
          ? synthParams.masterGain
          : 1.0;
        const state = { ...(track[0]?.params ?? {}) };
        for (let i = 0; i < track.length; i += 1) {
          const event = track[i];
          if (event?.params) {
            Object.assign(state, event.params);
          }
          const f1 = state.F1 ?? synthParams.F1;
          const f2 = state.F2 ?? synthParams.F2;
          const f3 = state.F3 ?? synthParams.F3;
          const f4 = state.F4 ?? synthParams.F4;
          const f5 = state.F5 ?? synthParams.F5;
          const f6 = state.F6 ?? synthParams.F6;
          const delF1 = Number.isFinite(f1) && f1 > 0 ? f1 / 500 : 1;
          const delF2 = Number.isFinite(f2) && f2 > 0 ? f2 / 1500 : 1;
          let a2Cor = delF1 * delF1;
          const a2Skrt = delF2 * delF2;
          const a3Cor = a2Cor * a2Skrt;
          a2Cor = delF2 !== 0 ? a2Cor / delF2 : a2Cor;
          const n12Cor = proximity(f2 - f1);
          const n23Cor = proximity(f3 - f2 - 50);
          const n34Cor = proximity(f4 - f3 - 150);

          const voiceDb = state.AV ?? -70;
          const voiceParDb = state.AVS ?? -70;
          const aspDb = state.AH ?? -70;
          const fricDb = state.AF ?? -70;
          const goDb = state.GO ?? 47;
          const mix = state.SW === 1 ? 1 : synthParams.parallelMix;
          const fricDbAdjusted = state.SW === 1 ? Math.max(fricDb, aspDb) : fricDb;

          const voiceGain = dbToLinear(voiceDb + ndbScale.AV);
          const aspGain = dbToLinear(aspDb + ndbScale.AH);
          const fricGain =
            dbToLinear(fricDbAdjusted + ndbScale.AF) * parallelScale;
          const voiceParGain =
            dbToLinear(voiceParDb + ndbScale.AVS) * 10 * parallelScale;
          const bypassGain =
            dbToLinear((state.AB ?? -70) + ndbScale.AB) * parallelScale;
          const nasalGain =
            dbToLinear((state.AN ?? -70) + ndbScale.AN) * parallelScale;
          const masterGain = Math.min(
            5.0,
            dbToLinear(goDb) * baseBoost * outputScale
          );

          const parallelLinear = [
            dbToLinear((state.A1 ?? -70) + n12Cor + ndbScale.A1),
            dbToLinear((state.A2 ?? -70) + n12Cor + n12Cor + n23Cor + ndbScale.A2) *
              a2Cor,
            dbToLinear((state.A3 ?? -70) + n23Cor + n23Cor + n34Cor + ndbScale.A3) *
              a3Cor,
            dbToLinear((state.A4 ?? -70) + n34Cor + n34Cor + ndbScale.A4) * a3Cor,
            dbToLinear((state.A5 ?? -70) + ndbScale.A5) * a3Cor,
            dbToLinear((state.A6 ?? -70) + ndbScale.A6) * a3Cor,
          ];
          const formantFreqs = [f1, f2, f3, f4, f5, f6];
          for (let idx = 0; idx < parallelLinear.length; idx += 1) {
            let value = parallelLinear[idx] * parallelScale;
            if (idx >= 1) {
              const freq = formantFreqs[idx];
              if (Number.isFinite(freq) && freq > 0) {
                const w = (2 * Math.PI * freq) / ctx.sampleRate;
                const diffGain = Math.sqrt(2 - 2 * Math.cos(w));
                if (diffGain > 0) {
                  value /= diffGain;
                }
              }
            }
            ranges.parallelFormantGain = updateRange(
              ranges.parallelFormantGain,
              Math.abs(value)
            );
          }

          ranges.voiceGain = updateRange(ranges.voiceGain, voiceGain);
          ranges.aspGain = updateRange(ranges.aspGain, aspGain);
          ranges.fricGain = updateRange(ranges.fricGain, fricGain);
          ranges.parallelVoiceGain = updateRange(
            ranges.parallelVoiceGain,
            voiceParGain
          );
          ranges.parallelBypassGain = updateRange(
            ranges.parallelBypassGain,
            bypassGain
          );
          ranges.parallelNasalGain = updateRange(
            ranges.parallelNasalGain,
            nasalGain
          );
          ranges.masterGain = updateRange(ranges.masterGain, masterGain);
          ranges.mix = updateRange(ranges.mix, mix);
        }

        const warnings = [];
        if (
          Number.isFinite(parallelScale) &&
          parallelScale > 0 &&
          parallelScale < 0.05
        ) {
          warnings.push(
            `parallelGainScale=${parallelScale.toFixed(3)} is very low; parallel branch likely inaudible`
          );
        }
        if (
          ranges.mix?.max > 0 &&
          (ranges.parallelVoiceGain?.max ?? 0) < 1e-3 &&
          (ranges.fricGain?.max ?? 0) < 1e-3
        ) {
          warnings.push(
            "Parallel gains peak below 1e-3; expect muted consonants when SW=1"
          );
        }
        return { ranges, warnings, parallelScale };
      }

      function collectParamRange(track, key, fallback) {
        let min = Infinity;
        let max = -Infinity;
        let current = fallback;
        for (const event of track) {
          if (Number.isFinite(event?.params?.[key])) {
            current = event.params[key];
          }
          if (Number.isFinite(current)) {
            min = Math.min(min, current);
            max = Math.max(max, current);
          }
        }
        if (!Number.isFinite(min) || !Number.isFinite(max)) return null;
        return { min, max };
      }

      function summarizeLfMode(track, fallbackMode = 0) {
        const counts = { 0: 0, 1: 0, 2: 0 };
        const seconds = { 0: 0, 1: 0, 2: 0 };
        let current = Number.isFinite(fallbackMode)
          ? Math.round(fallbackMode)
          : 0;
        for (let i = 0; i < track.length; i += 1) {
          const event = track[i];
          if (Number.isFinite(event?.params?.lfMode)) {
            current = Math.round(event.params.lfMode);
          }
          counts[current] = (counts[current] || 0) + 1;
          const duration =
            i < track.length - 1 ? track[i + 1].time - event.time : 0;
          if (Number.isFinite(duration) && duration > 0) {
            seconds[current] = (seconds[current] || 0) + duration;
          }
        }
        return { counts, seconds };
      }

      function findVoicingIssues(track, fallback) {
        const issues = [];
        const state = {
          F0: fallback?.F0 ?? 0,
          AV: fallback?.AV ?? 0,
          AVS: fallback?.AVS ?? 0,
          AF: fallback?.AF ?? 0,
          AH: fallback?.AH ?? 0,
          SW: fallback?.SW ?? 0,
        };
        for (let i = 0; i < track.length; i += 1) {
          const event = track[i];
          if (event?.params) {
            for (const key of Object.keys(state)) {
              if (Number.isFinite(event.params[key])) {
                state[key] = event.params[key];
              }
            }
          }
          const voiced = (state.AV ?? 0) > 0 || (state.AVS ?? 0) > 0;
          const noise = (state.AF ?? 0) > 0 || (state.AH ?? 0) > 0;
          const f0 = state.F0 ?? 0;
          if (voiced && (!Number.isFinite(f0) || f0 <= 0)) {
            issues.push(
              `t=${event.time.toFixed(3)} ${event.phoneme ?? ""} voiced but F0=0`
            );
          } else if (f0 > 0 && !voiced && !noise) {
            issues.push(
              `t=${event.time.toFixed(3)} ${event.phoneme ?? ""} F0>0 but no AV/AVS/AF/AH`
            );
          }
          if (issues.length >= 6) break;
        }
        return issues;
      }

      function findEventAtTime(track, time) {
        if (!track || track.length === 0) return null;
        let current = track[0];
        for (const event of track) {
          if (event.time > time) break;
          current = event;
        }
        return current;
      }

      function getRunContext(now = ctx.currentTime) {
        if (!lastRun || !runStartTime) {
          return { relTime: null, event: null, inWindow: false, trackEnd: 0 };
        }
        const relTime = now - runStartTime;
        const trackEnd = lastRun.track?.length
          ? lastRun.track[lastRun.track.length - 1].time
          : 0;
        const inWindow = relTime >= -0.1 && relTime <= trackEnd + 0.5;
        const event = inWindow
          ? findEventAtTime(lastRun.track, Math.max(0, relTime))
          : null;
        return { relTime, event, inWindow, trackEnd };
      }

      function formatSpikePeak(value) {
        if (!Number.isFinite(value)) return "NaN";
        if (Math.abs(value) >= 10) return Number(value).toExponential(2);
        return Number(value).toFixed(3);
      }

      function formatSpikes(list) {
        if (!list || list.length === 0) return ["(none)"];
        return list.map(
          (spike, index) =>
            `${index}. t=${spike.time.toFixed(3)}s node=${spike.node} peak=${formatSpikePeak(
              spike.peak
            )} phoneme=${spike.phoneme || ""}`
        );
      }

      function formatPlstepEvents(list) {
        if (!list || list.length === 0) return ["(none)"];
        return list.map(
          (evt, index) => {
            const time = Number.isFinite(evt.time) ? evt.time.toFixed(3) : "n/a";
            const amp = Number.isFinite(evt.amplitudeLinear) ? evt.amplitudeLinear.toFixed(2) : "n/a";
            const db = Number.isFinite(evt.amplitudeDb) ? evt.amplitudeDb.toFixed(0) : "n/a";
            const trigger = evt.trigger || "?";
            const delta = Number.isFinite(evt.delta) ? evt.delta.toFixed(0) : "n/a";
            return `plstep: burst @${time}s amp=${amp} (${db}dB) trigger=${trigger} delta=${delta}`;
          }
        );
      }

      function formatLevel(value) {
        if (!Number.isFinite(value)) return "n/a";
        if (value === 0) return "0";
        const abs = Math.abs(value);
        if (abs < 1e-6) return value.toExponential(2);
        return value.toFixed(6);
      }

      function formatRange(range, digits = 1) {
        if (!range) return "n/a";
        return `${range.min.toFixed(digits)} - ${range.max.toFixed(digits)}`;
      }

      function formatMaxContext(time, phoneme) {
        if (!Number.isFinite(time)) return "";
        const label = phoneme ? ` ${phoneme}` : "";
        return ` @${time.toFixed(3)}s${label}`;
      }

      function formatTelemetry(map) {
        if (!map || map.size === 0) return ["(no telemetry yet)"];
        const entries = Array.from(map.entries()).sort(([a], [b]) =>
          a.localeCompare(b)
        );
        return entries.map(
          ([node, data]) => {
            const suffixParts = [];
            if (
              Number.isFinite(data.f0) ||
              Number.isFinite(data.rd) ||
              Number.isFinite(data.lfMode)
            ) {
              const f0 = Number.isFinite(data.f0) ? data.f0.toFixed(2) : "n/a";
              const rd = Number.isFinite(data.rd) ? data.rd.toFixed(2) : "n/a";
              const lfMode = Number.isFinite(data.lfMode)
                ? Math.round(data.lfMode)
                : "n/a";
              suffixParts.push(`f0=${f0} rd=${rd} lf=${lfMode}`);
            }
            if (
              Number.isFinite(data.freq) ||
              Number.isFinite(data.bw) ||
              Number.isFinite(data.gain)
            ) {
              const freq = Number.isFinite(data.freq)
                ? data.freq.toFixed(1)
                : "n/a";
              const bw = Number.isFinite(data.bw) ? data.bw.toFixed(1) : "n/a";
              const gain = Number.isFinite(data.gain)
                ? data.gain.toFixed(2)
                : "n/a";
              suffixParts.push(`f=${freq} bw=${bw} g=${gain}`);
            }
            if (Number.isFinite(data.inRms) || Number.isFinite(data.inPeak)) {
              const inRms = formatLevel(data.inRms);
              const inPeak = formatLevel(data.inPeak);
              suffixParts.push(`in=${inRms}/${inPeak}`);
            }
            if (
              Number.isFinite(data.gainAvg) ||
              Number.isFinite(data.gainPeak) ||
              Number.isFinite(data.cutoff)
            ) {
              const gainAvg = Number.isFinite(data.gainAvg)
                ? data.gainAvg.toFixed(3)
                : "n/a";
              const gainPeak = Number.isFinite(data.gainPeak)
                ? data.gainPeak.toFixed(3)
                : "n/a";
              const cutoff = Number.isFinite(data.cutoff)
                ? data.cutoff.toFixed(0)
                : "n/a";
              suffixParts.push(`gain=${gainAvg}/${gainPeak} cf=${cutoff}`);
            }
            const suffix = suffixParts.length ? ` ${suffixParts.join(" ")}` : "";
            const max = telemetryMax.get(node);
            let maxSuffix = "";
            if (max) {
              const maxRms = formatLevel(max.rms);
              const maxPeak = formatLevel(max.peak);
              const rmsContext = formatMaxContext(
                max.rmsTime,
                max.rmsPhoneme
              );
              const peakContext = formatMaxContext(
                max.peakTime,
                max.peakPhoneme
              );
              maxSuffix = ` | max rms=${maxRms}${rmsContext} peak=${maxPeak}${peakContext}`;
              if (
                Number.isFinite(max.freqMin) &&
                Number.isFinite(max.freqMax)
              ) {
                maxSuffix += ` f=[${max.freqMin.toFixed(1)}-${max.freqMax.toFixed(1)}]`;
              }
              if (
                Number.isFinite(max.bwMin) &&
                Number.isFinite(max.bwMax)
              ) {
                maxSuffix += ` bw=[${max.bwMin.toFixed(1)}-${max.bwMax.toFixed(1)}]`;
              }
            }
            return `${node}: rms=${formatLevel(data.rms)} peak=${formatLevel(data.peak)}${suffix}${maxSuffix}`;
          }
        );
      }

      function formatMeters(map) {
        if (!map || map.size === 0) return ["(no meters yet)"];
        const entries = Array.from(map.entries()).sort(([a], [b]) =>
          a.localeCompare(b)
        );
        return entries.map(
          ([node, data]) => {
            const max = meterMax.get(node);
            let suffix = "";
            if (max) {
              const rmsContext = formatMaxContext(
                max.rmsTime,
                max.rmsPhoneme
              );
              const peakContext = formatMaxContext(
                max.peakTime,
                max.peakPhoneme
              );
              suffix = ` | max rms=${formatLevel(max.rms)}${rmsContext} peak=${formatLevel(
                max.peak
              )}${peakContext}`;
            }
            return `${node}: rms=${formatLevel(data.rms)} peak=${formatLevel(
              data.peak
            )}${suffix}`;
          }
        );
      }

      function updateDiagnostics() {
        if (!lastRun) return;
        lastDiagnostics = buildDiagnostics({
          phrase: lastRun.phrase,
          baseF0: lastRun.baseF0,
          track: lastRun.track,
          telemetry,
          meters: meterValues,
        });
        diagnosticsEl.value = lastDiagnostics;
      }

      // Store PLSTEP burst events for diagnostics display
      const plstepEvents = [];

      function handleTelemetry(data) {
        // Handle PLSTEP burst events specially
        if (data?.type === 'plstep') {
          const { relTime, event, inWindow } = getRunContext();
          if (inWindow || !lastRun) {
            plstepEvents.push({
              time: data.time,
              relTime,
              amplitudeLinear: data.amplitudeLinear,
              amplitudeDb: data.amplitudeDb,
              trigger: data.trigger,
              delta: data.delta,
              phoneme: event?.phoneme ?? '',
            });
            // Keep only last 10 PLSTEP events
            if (plstepEvents.length > 10) plstepEvents.shift();
            updateDiagnostics();
          }
          return;
        }
        if (!data?.node) return;
        const { relTime, event, inWindow } = getRunContext();
        telemetry.set(data.node, {
          rms: data.rms,
          peak: data.peak,
          f0: data.f0,
          rd: data.rd,
          lfMode: data.lfMode,
          freq: data.freq,
          bw: data.bw,
          gain: data.gain,
          inRms: data.inRms,
          inPeak: data.inPeak,
          cutoff: data.cutoff,
          gainAvg: data.gainAvg,
          gainPeak: data.gainPeak,
          time: relTime,
          phoneme: event?.phoneme ?? "",
        });
        const prev = telemetryMax.get(data.node) || { rms: 0, peak: 0 };
        const next = { ...prev };
        if (
          inWindow &&
          Number.isFinite(data.rms) &&
          data.rms > (prev.rms ?? 0)
        ) {
          next.rms = data.rms;
          next.rmsTime = relTime;
          next.rmsPhoneme = event?.phoneme ?? "";
        }
        if (
          inWindow &&
          Number.isFinite(data.peak) &&
          data.peak > (prev.peak ?? 0)
        ) {
          next.peak = data.peak;
          next.peakTime = relTime;
          next.peakPhoneme = event?.phoneme ?? "";
        }
        if (inWindow && Number.isFinite(data.freq)) {
          if (!Number.isFinite(next.freqMin) || data.freq < next.freqMin) {
            next.freqMin = data.freq;
          }
          if (!Number.isFinite(next.freqMax) || data.freq > next.freqMax) {
            next.freqMax = data.freq;
          }
        }
        if (inWindow && Number.isFinite(data.bw)) {
          if (!Number.isFinite(next.bwMin) || data.bw < next.bwMin) {
            next.bwMin = data.bw;
          }
          if (!Number.isFinite(next.bwMax) || data.bw > next.bwMax) {
            next.bwMax = data.bw;
          }
        }
        telemetryMax.set(data.node, next);
        if (!lastRun) return;
        if (telemetryTimer) return;
        telemetryTimer = setTimeout(() => {
          telemetryTimer = null;
          updateDiagnostics();
        }, 250);
      }

      function buildDiagnostics({ phrase, baseF0, track, telemetry, meters }) {
        const summary = summarizeTrack(track);
        const parallelSummary = summarizeParallel(track);
        const fallbackMode = Number.isFinite(track[0]?.params?.lfMode)
          ? track[0].params.lfMode
          : synth.params.lfMode;
        const fallbackF0 = Number.isFinite(track[0]?.params?.F0)
          ? track[0].params.F0
          : synth.params.f0;
        const fallbackF1 = Number.isFinite(track[0]?.params?.F1)
          ? track[0].params.F1
          : synth.params.F1;
        const fallbackF2 = Number.isFinite(track[0]?.params?.F2)
          ? track[0].params.F2
          : synth.params.F2;
        const fallbackF3 = Number.isFinite(track[0]?.params?.F3)
          ? track[0].params.F3
          : synth.params.F3;
        const lfSummary = summarizeLfMode(track, fallbackMode);
        const f1Range = collectParamRange(track, "F1", fallbackF1);
        const f2Range = collectParamRange(track, "F2", fallbackF2);
        const f3Range = collectParamRange(track, "F3", fallbackF3);
        const voicingIssues = findVoicingIssues(track, { F0: fallbackF0 });
        const derived = analyzeTrackGains(track, synth.params);
        const cascade1Range = telemetryMax.get("cascade-1");
        const cascade2Range = telemetryMax.get("cascade-2");
        const cascade3Range = telemetryMax.get("cascade-3");
        const lines = [];
        lines.push(`Phrase: ${phrase}`);
        lines.push(`Base F0: ${baseF0}`);
        lines.push(`Events: ${summary.events}`);
        lines.push(`Total time: ${summary.totalTime.toFixed(3)}s`);
        lines.push(`Voiced events: ${summary.voicedEvents}`);
        lines.push(`F0 range: ${summary.f0Min.toFixed(1)} - ${summary.f0Max.toFixed(1)} Hz`);
        lines.push(
          `LF mode time: legacy=${(lfSummary.seconds[0] || 0).toFixed(3)}s (${lfSummary.counts[0] || 0}) | LF_LM=${(lfSummary.seconds[1] || 0).toFixed(3)}s (${lfSummary.counts[1] || 0}) | LF_CALM=${(lfSummary.seconds[2] || 0).toFixed(3)}s (${lfSummary.counts[2] || 0})`
        );
        lines.push(
          `Formant range: F1 ${formatRange(f1Range)} Hz | F2 ${formatRange(f2Range)} Hz | F3 ${formatRange(f3Range)} Hz`
        );
        lines.push(
          `SW=1 events: ${parallelSummary.swOn} | parallel events: ${parallelSummary.parallelEvents}`
        );
        lines.push(
          `SW=1 time: ${parallelSummary.swOnSeconds.toFixed(3)}s (${parallelSummary.swOnShare.toFixed(1)}%)`
        );
        if (derived) {
          lines.push(
            `Parallel gain scale: ${derived.parallelScale.toFixed(3)} | mix range: ${formatRange(derived.ranges.mix, 2)}`
          );
          lines.push("Derived gains (linear):");
          lines.push(
            `voice ${formatRange(derived.ranges.voiceGain, 6)} | asp ${formatRange(derived.ranges.aspGain, 6)} | fric ${formatRange(derived.ranges.fricGain, 6)}`
          );
          lines.push(
            `parallel voice ${formatRange(derived.ranges.parallelVoiceGain, 6)} | bypass ${formatRange(derived.ranges.parallelBypassGain, 6)} | nasal ${formatRange(derived.ranges.parallelNasalGain, 6)}`
          );
          lines.push(
            `parallel formants ${formatRange(derived.ranges.parallelFormantGain, 6)} | master ${formatRange(derived.ranges.masterGain, 6)}`
          );
          lines.push("Warnings:");
          lines.push(...(derived.warnings.length ? derived.warnings : ["(none)"]));
          lines.push("");
        }
        lines.push("Formant automation check:");
        lines.push(
          `cascade-1 f=[${Number.isFinite(cascade1Range?.freqMin) ? cascade1Range.freqMin.toFixed(1) : "n/a"}-${Number.isFinite(cascade1Range?.freqMax) ? cascade1Range.freqMax.toFixed(1) : "n/a"}] vs track ${formatRange(f1Range)}`
        );
        lines.push(
          `cascade-2 f=[${Number.isFinite(cascade2Range?.freqMin) ? cascade2Range.freqMin.toFixed(1) : "n/a"}-${Number.isFinite(cascade2Range?.freqMax) ? cascade2Range.freqMax.toFixed(1) : "n/a"}] vs track ${formatRange(f2Range)}`
        );
        lines.push(
          `cascade-3 f=[${Number.isFinite(cascade3Range?.freqMin) ? cascade3Range.freqMin.toFixed(1) : "n/a"}-${Number.isFinite(cascade3Range?.freqMax) ? cascade3Range.freqMax.toFixed(1) : "n/a"}] vs track ${formatRange(f3Range)}`
        );
        lines.push("");
        lines.push("");
        lines.push("First events:");
        track.slice(0, 8).forEach((e, index) => {
          const sw = Number.isFinite(e.params?.SW) ? e.params.SW.toFixed(0) : "n/a";
          lines.push(
            `${index}. t=${e.time.toFixed(3)} ${e.phoneme ?? ""} F0=${(e.params?.F0 ?? 0).toFixed(1)} AV=${(e.params?.AV ?? 0).toFixed(1)} AVS=${(e.params?.AVS ?? 0).toFixed(1)} AH=${(e.params?.AH ?? 0).toFixed(1)} AF=${(e.params?.AF ?? 0).toFixed(1)} SW=${sw}`
          );
        });
        lines.push("");
        lines.push("Last events:");
        track.slice(-6).forEach((e, index) => {
          const sw = Number.isFinite(e.params?.SW) ? e.params.SW.toFixed(0) : "n/a";
          lines.push(
            `${track.length - 6 + index}. t=${e.time.toFixed(3)} ${e.phoneme ?? ""} F0=${(e.params?.F0 ?? 0).toFixed(1)} AV=${(e.params?.AV ?? 0).toFixed(1)} AVS=${(e.params?.AVS ?? 0).toFixed(1)} AH=${(e.params?.AH ?? 0).toFixed(1)} AF=${(e.params?.AF ?? 0).toFixed(1)} SW=${sw}`
          );
        });
        lines.push("");
        lines.push("Voicing issues:");
        lines.push(...(voicingIssues.length ? voicingIssues : ["(none)"]));
        lines.push("");
        lines.push("Telemetry (latest block):");
        lines.push(...formatTelemetry(telemetry));
        lines.push("");
        lines.push("Meters (RMS/peak):");
        lines.push(...formatMeters(meters || meterValues));
        lines.push("");
        lines.push("PLSTEP bursts (plosive release transients):");
        lines.push(...formatPlstepEvents(plstepEvents));
        lines.push("");
        lines.push(`Spikes (peak > ${spikeThreshold}):`);
        lines.push(...formatSpikes(spikeEvents));
        return lines.join("\n");
      }

      function attachMeters() {
        const nodes = synth.nodes;
        if (!nodes?.outputSum || meters.size > 0) return;
        const targets = [
          { name: "cascade-out", node: nodes.cascadeOutGain },
          { name: "parallel-out", node: nodes.parallelOutGain },
          { name: "output-sum", node: nodes.outputSum },
        ];
        for (const target of targets) {
          if (!target.node) continue;
          const analyser = ctx.createAnalyser();
          analyser.fftSize = 2048;
          target.node.connect(analyser);
          meters.set(target.name, analyser);
        }
        startMeterLoop();
      }

      function startMeterLoop() {
        if (meterTimer) return;
        meterTimer = setInterval(() => {
          const { relTime, event, inWindow } = getRunContext();
          for (const [name, analyser] of meters.entries()) {
            const data = readMeter(analyser);
            meterValues.set(name, {
              ...data,
              time: relTime,
              phoneme: event?.phoneme ?? "",
            });
            const prev = meterMax.get(name) || { rms: 0, peak: 0 };
            const next = { ...prev };
            if (
              inWindow &&
              Number.isFinite(data.rms) &&
              data.rms > (prev.rms ?? 0)
            ) {
              next.rms = data.rms;
              next.rmsTime = relTime;
              next.rmsPhoneme = event?.phoneme ?? "";
            }
            if (
              inWindow &&
              Number.isFinite(data.peak) &&
              data.peak > (prev.peak ?? 0)
            ) {
              next.peak = data.peak;
              next.peakTime = relTime;
              next.peakPhoneme = event?.phoneme ?? "";
            }
            meterMax.set(name, next);
            recordSpike(name, data);
          }
          updateDiagnostics();
        }, 200);
      }

      function recordSpike(name, data) {
        if (!lastRun || !runStartTime || !data || !Number.isFinite(data.peak)) return;
        if (data.peak <= spikeThreshold) return;
        const now = ctx.currentTime;
        const lastAt = lastSpikeAt.get(name) ?? -Infinity;
        if (now - lastAt < spikeCooldown) return;
        const relTime = now - runStartTime;
        const trackEnd = lastRun.track?.length
          ? lastRun.track[lastRun.track.length - 1].time
          : 0;
        if (relTime < -0.1 || relTime > trackEnd + 0.5) return;
        lastSpikeAt.set(name, now);
        const event = findEventAtTime(lastRun.track, relTime);
        spikeEvents.push({
          time: Math.max(0, relTime),
          node: name,
          peak: data.peak,
          phoneme: event?.phoneme ?? "",
        });
        if (spikeEvents.length > 6) spikeEvents.shift();
      }

      function readMeter(analyser) {
        const buffer = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(buffer);
        let sum = 0;
        let peak = 0;
        for (let i = 0; i < buffer.length; i += 1) {
          const v = buffer[i];
          sum += v * v;
          const av = Math.abs(v);
          if (av > peak) peak = av;
        }
        const rms = Math.sqrt(sum / buffer.length);
        return { rms, peak };
      }
    </script>
  </body>
</html>
