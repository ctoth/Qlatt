<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>QLATT Offline Renderer</title>
  </head>
  <body>
    <script type="module">
      import { KlattSynth } from "../src/klatt-synth.js";
      import { textToKlattTrack } from "../src/tts-frontend.js";

      function summarizeTrack(track) {
        const totalTime = track.length ? track[track.length - 1].time : 0;
        const voiced = track.filter(
          (event) => (event.params?.AV ?? 0) > 0 || (event.params?.AVS ?? 0) > 0
        );
        const f0Values = track
          .map((event) => event.params?.F0 ?? 0)
          .filter((v) => v > 0);
        const f0Min = f0Values.length ? Math.min(...f0Values) : 0;
        const f0Max = f0Values.length ? Math.max(...f0Values) : 0;
        return {
          events: track.length,
          totalTime,
          voicedEvents: voiced.length,
          f0Min,
          f0Max,
        };
      }

      async function renderOffline({
        phrase,
        baseF0 = 110,
        sampleRate = 22050,
        leadTime = 0.05,
        tailTime = 0.2,
        track,
        includeTrack = false,
        includeTelemetry = false,
        agcRmsLevel,
        applyAgc = false,
        agcMode = "utterance",
        sourceMode,
        openPhaseRatio,
      }) {
        const resolvedTrack = Array.isArray(track)
          ? track
          : textToKlattTrack(phrase, baseF0);
        const totalTime =
          (resolvedTrack.length ? resolvedTrack[resolvedTrack.length - 1].time : 0) +
          leadTime +
          tailTime;
        const length = Math.max(1, Math.ceil(totalTime * sampleRate));

        const ctx = new OfflineAudioContext(1, length, sampleRate);
        const synth = new KlattSynth(ctx);
        const telemetry = includeTelemetry ? { nodes: {}, events: {} } : null;
        if (includeTelemetry) {
          synth.setTelemetryHandler((data) => {
            if (!data || !data.type) return;
            if (data.type === "metrics") {
              const nodeId = data.node || "unknown";
              const entry = telemetry.nodes[nodeId] || {
                maxRms: 0,
                maxPeak: 0,
                maxInRms: 0,
                maxInPeak: 0,
                count: 0,
              };
              if (Number.isFinite(data.rms)) {
                entry.maxRms = Math.max(entry.maxRms, data.rms);
              }
              if (Number.isFinite(data.peak)) {
                entry.maxPeak = Math.max(entry.maxPeak, data.peak);
              }
              if (Number.isFinite(data.inRms)) {
                entry.maxInRms = Math.max(entry.maxInRms, data.inRms);
              }
              if (Number.isFinite(data.inPeak)) {
                entry.maxInPeak = Math.max(entry.maxInPeak, data.inPeak);
              }
              entry.count += 1;
              telemetry.nodes[nodeId] = entry;
              return;
            }
            telemetry.events[data.type] = (telemetry.events[data.type] || 0) + 1;
          });
        }
        await synth.initialize();
        if (Number.isFinite(sourceMode)) {
          synth.setParam("sourceMode", Number(sourceMode), ctx.currentTime);
        }
        if (Number.isFinite(openPhaseRatio)) {
          synth.setParam("openPhaseRatio", Number(openPhaseRatio), ctx.currentTime);
        }
        synth.scheduleTrack(resolvedTrack, leadTime);
        const buffer = await ctx.startRendering();
        const channel = buffer.getChannelData(0);

        let rms = 0;
        let peak = 0;
        const samples = new Array(channel.length);
        for (let i = 0; i < channel.length; i += 1) {
          const v = channel[i];
          samples[i] = v;
          rms += v * v;
          const av = Math.abs(v);
          if (av > peak) peak = av;
        }
        rms = channel.length ? Math.sqrt(rms / channel.length) : 0;
        let agcScale = 1;
        const target = Number.isFinite(agcRmsLevel) ? agcRmsLevel : NaN;
        if (applyAgc && Number.isFinite(target) && target > 0) {
          const applyAgcScale = (start, end, desired) => {
            let sum = 0;
            let maxAbs = 0;
            const length = end - start;
            if (length <= 0) return;
            for (let j = start; j < end; j += 1) {
              const v = samples[j];
              sum += v * v;
              const av = Math.abs(v);
              if (av > maxAbs) maxAbs = av;
            }
            const currentRms = length ? Math.sqrt(sum / length) : 0;
            if (currentRms <= 0) return;
            let scale = desired / currentRms;
            if (scale * maxAbs >= 1 && maxAbs > 0) {
              scale = 0.99 / maxAbs;
            }
            for (let j = start; j < end; j += 1) {
              samples[j] *= scale;
            }
          };

          if (agcMode === "frame" && resolvedTrack.length > 0) {
            const sr = sampleRate;
            for (let i = 0; i < resolvedTrack.length; i += 1) {
              const event = resolvedTrack[i];
              const next = resolvedTrack[i + 1];
              const start = Math.floor((leadTime + event.time) * sr);
              const end = Math.floor(
                (leadTime + (next?.time ?? event.time + 0.005)) * sr
              );
              if (end <= start || start >= samples.length) continue;
              const sliceEnd = Math.min(end, samples.length);
              applyAgcScale(start, sliceEnd, target);
            }
            rms = 0;
            peak = 0;
            for (let i = 0; i < samples.length; i += 1) {
              const v = samples[i];
              rms += v * v;
              const av = Math.abs(v);
              if (av > peak) peak = av;
            }
            rms = samples.length ? Math.sqrt(rms / samples.length) : 0;
            agcScale = NaN;
          } else if (rms > 0) {
            let maxAbs = 0;
            for (let i = 0; i < samples.length; i += 1) {
              const av = Math.abs(samples[i]);
              if (av > maxAbs) maxAbs = av;
            }
            agcScale = target / rms;
            if (agcScale * maxAbs >= 1 && maxAbs > 0) {
              agcScale = 0.99 / maxAbs;
            }
            rms = 0;
            peak = 0;
            for (let i = 0; i < samples.length; i += 1) {
              const v = samples[i] * agcScale;
              samples[i] = v;
              rms += v * v;
              const av = Math.abs(v);
              if (av > peak) peak = av;
            }
            rms = samples.length ? Math.sqrt(rms / samples.length) : 0;
          }
        }

        return {
          phrase,
          baseF0,
          sampleRate,
          leadTime,
          tailTime,
          length,
          metrics: { rms, peak },
          agc: applyAgc ? { target, scale: agcScale, mode: agcMode } : undefined,
          trackSummary: summarizeTrack(resolvedTrack),
          track: includeTrack ? resolvedTrack : undefined,
          telemetry: includeTelemetry ? telemetry : undefined,
          samples,
        };
      }

      window.renderOffline = renderOffline;
    </script>
  </body>
</html>
