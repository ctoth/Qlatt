bacon: "0.1"
name: klsyn88-synth
meta:
  primitives: ./registry.yaml
  semantics: ./semantics.yaml
  description: |
    klsyn88 formant synthesizer topology (parwav.c):
    - Oversampled glottal source with integrated noise/tilt
    - Pitch-synchronous F1 modulation
    - Fujisaki compensation on cascade F2/F3
    - Fixed F7/F8 when NFCASC >= 7/8

nodes:
  glottalSource:
    type: oversampled-glottal-source
    params:
      f0: { bind: F0 }
      av: { bind: avDb }
      aturb: { bind: Aturb }
      tilt: { bind: TLTdb }
      openQuotient: { bind: Kopen }
      skew: { bind: Kskew }
      asymmetry: { bind: as }
      source: { bind: ss }
      seed: { bind: seed }

  voiceGain:
    type: gain
    params:
      gain: { bind: voiceGain }

  parVoiceGain:
    type: gain
    params:
      gain: { bind: parVoiceGain }

  aspGain:
    type: gain
    params:
      gain: { bind: aspGain }

  fricGain:
    type: gain
    params:
      gain: { bind: fricGain }

  cascadeMix:
    type: gain
    params:
      gain: 1.0

  parallelVoiceMix:
    type: gain
    params:
      gain: 1.0

  diff:
    type: differentiator

  parallelSourceSum:
    type: gain
    params:
      gain: 1.0

  nz:
    type: antiresonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: FNZ }
      bandwidth: { bind: BNZ }

  np:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: FNP }
      bandwidth: { bind: BNP }

  cascadePolarityGain:
    type: gain
    params:
      gain: { bind: cascadePolarity }

  cascadeF8:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF8Freq }
      bandwidth: { bind: cascadeF8Bw }

  cascadeF7:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF7Freq }
      bandwidth: { bind: cascadeF7Bw }

  cascadeF6:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF6Freq }
      bandwidth: { bind: cascadeF6Bw }

  cascadeF5:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF5Freq }
      bandwidth: { bind: cascadeF5Bw }

  cascadeF4:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF4Freq }
      bandwidth: { bind: cascadeF4Bw }

  cascadeF3:
    type: fujisaki-resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF3Freq }
      bandwidth: { bind: cascadeF3Bw }

  cascadeF2:
    type: fujisaki-resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: cascadeF2Freq }
      bandwidth: { bind: cascadeF2Bw }

  cascadeF1:
    type: pitch-sync-mod
    params:
      f0: { bind: F0 }
      openQuotient: { bind: Kopen }
      f1: { bind: F1 }
      b1: { bind: B1 }
      dF1: { bind: dF1hz }
      dB1: { bind: dB1hz }
      skew: { bind: Kskew }
      source: { bind: ss }

  parallelF1:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F1 }
      bandwidth: { bind: B1p }

  parallelNasal:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: FNP }
      bandwidth: { bind: BNP }

  parallelF2:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F2 }
      bandwidth: { bind: B2p }

  parallelF3:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F3 }
      bandwidth: { bind: B3p }

  parallelF4:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F4 }
      bandwidth: { bind: B4p }

  parallelF5:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F5 }
      bandwidth: { bind: B5p }

  parallelF6:
    type: resonator
    options:
      bypassAtZero: true
    params:
      frequency: { bind: F6 }
      bandwidth: { bind: B6p }

  parallelF1Gain:
    type: gain
    params:
      gain: { bind: a1Gain }

  parallelNasalGain:
    type: gain
    params:
      gain: { bind: anpGain }

  parallelF2Gain:
    type: gain
    params:
      gain: { bind: a2Gain }

  parallelF3Gain:
    type: gain
    params:
      gain: { bind: a3Gain }

  parallelF4Gain:
    type: gain
    params:
      gain: { bind: a4Gain }

  parallelF5Gain:
    type: gain
    params:
      gain: { bind: a5Gain }

  parallelF6Gain:
    type: gain
    params:
      gain: { bind: a6Gain }

  parallelBypassGain:
    type: gain
    params:
      gain: { bind: abGain }

  parallelSum:
    type: gain
    params:
      gain: 1.0

  outputSum:
    type: gain
    params:
      gain: 1.0

  gain0Gain:
    type: gain
    params:
      gain: { bind: gain0Linear }

  finalPolarityGain:
    type: gain
    params:
      gain: -1.0

connections:
  # Glottal source outputs (voice=0, noise=1)
  - [{ node: glottalSource, port: 0 }, voiceGain]
  - [{ node: glottalSource, port: 0 }, parVoiceGain]
  - [{ node: glottalSource, port: 1 }, aspGain]
  - [{ node: glottalSource, port: 1 }, fricGain]

  # Cascade source mix (voice + aspiration)
  - [voiceGain, cascadeMix]
  - [aspGain, cascadeMix]

  # Parallel voicing mix (par voice + aspiration)
  - [parVoiceGain, parallelVoiceMix]
  - [aspGain, parallelVoiceMix]

  # UGLOT1 = diff(par_glotout)
  - [parallelVoiceMix, diff]

  # Parallel source = UGLOT1 + frication
  - [diff, parallelSourceSum]
  - [fricGain, parallelSourceSum]

  # Cascade chain: NZ -> NP -> polarity -> F8 -> F7 -> F6 -> F5 -> F4 -> F3 -> F2 -> F1
  - [cascadeMix, nz]
  - [nz, np]
  - [np, cascadePolarityGain]
  - [cascadePolarityGain, cascadeF8]
  - [cascadeF8, cascadeF7]
  - [cascadeF7, cascadeF6]
  - [cascadeF6, cascadeF5]
  - [cascadeF5, cascadeF4]
  - [cascadeF4, cascadeF3]
  - [cascadeF3, cascadeF2]
  - [cascadeF2, cascadeF1]
  - [cascadeF1, outputSum]

  # Parallel F1 and nasal (input = par_glotout)
  - [parallelVoiceMix, parallelF1]
  - [parallelF1, parallelF1Gain]
  - [parallelF1Gain, outputSum]

  - [parallelVoiceMix, parallelNasal]
  - [parallelNasal, parallelNasalGain]
  - [parallelNasalGain, outputSum]

  # Parallel F2-F6 and bypass (input = UGLOT1 + frication)
  - [parallelSourceSum, parallelF2]
  - [parallelF2, parallelF2Gain]
  - [parallelF2Gain, parallelSum]

  - [parallelSourceSum, parallelF3]
  - [parallelF3, parallelF3Gain]
  - [parallelF3Gain, parallelSum]

  - [parallelSourceSum, parallelF4]
  - [parallelF4, parallelF4Gain]
  - [parallelF4Gain, parallelSum]

  - [parallelSourceSum, parallelF5]
  - [parallelF5, parallelF5Gain]
  - [parallelF5Gain, parallelSum]

  - [parallelSourceSum, parallelF6]
  - [parallelF6, parallelF6Gain]
  - [parallelF6Gain, parallelSum]

  - [parallelSourceSum, parallelBypassGain]
  - [parallelBypassGain, parallelSum]

  # Parallel sum into output
  - [parallelSum, outputSum]

  # Final gain and polarity
  - [outputSum, gain0Gain]
  - [gain0Gain, finalPolarityGain]

outputs:
  - finalPolarityGain
